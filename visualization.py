#!/usr/bin/env python3
"""
scFASTopic ÂèØËßÜÂåñÊ®°Âùó
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import umap
from pathlib import Path
from typing import Dict, Optional, List
import pickle

class ScFastopicVisualizer:
    """scFASTopicÂèØËßÜÂåñÂô®"""
    
    def __init__(self, output_dir: str = "visualization"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # ËÆæÁΩÆmatplotlibÊ†∑Âºè
        plt.style.use('default')
        sns.set_palette("husl")
        
    def load_matrices(self, 
                     dataset_name: str, 
                     n_topics: int,
                     results_dir: str = "results") -> Dict[str, np.ndarray]:
        """
        Âä†ËΩΩ‰øùÂ≠òÁöÑÁü©ÈòµÊñá‰ª∂
        
        Args:
            dataset_name: Êï∞ÊçÆÈõÜÂêçÁß∞
            n_topics: ‰∏ªÈ¢òÊï∞Èáè
            results_dir: ÁªìÊûúÁõÆÂΩï
            
        Returns:
            matrices: Áü©ÈòµÂ≠óÂÖ∏
        """
        results_path = Path(results_dir)
        matrices = {}
        
        # ÈúÄË¶ÅÂä†ËΩΩÁöÑÁü©ÈòµÁ±ªÂûã
        matrix_types = ['cell_embedding', 'cell_topic', 'topic_gene', 
                       'gene_embedding', 'topic_embedding']
        
        for matrix_type in matrix_types:
            file_name = f"{dataset_name}_{matrix_type}_{n_topics}.pkl"
            file_path = results_path / file_name
            
            if file_path.exists():
                with open(file_path, 'rb') as f:
                    data = pickle.load(f)
                    matrices[matrix_type.replace('_', '_')] = data['matrix']
                print(f"‚úÖ Loaded {matrix_type}: {data['shape']}")
            else:
                print(f"‚ö†Ô∏è Matrix file not found: {file_path}")
        
        return matrices
    
    def create_umap_plot(self,
                        cell_topic_matrix: np.ndarray,
                        cell_info: Optional[pd.DataFrame] = None,
                        dataset_name: str = "Dataset",
                        n_topics: int = 20,
                        save: bool = True) -> str:
        """
        ÂàõÂª∫UMAPÂèØËßÜÂåñ
        
        Args:
            cell_topic_matrix: Cell-topicÁü©Èòµ
            cell_info: ÁªÜËÉû‰ø°ÊÅØ
            dataset_name: Êï∞ÊçÆÈõÜÂêçÁß∞
            n_topics: ‰∏ªÈ¢òÊï∞Èáè
            save: ÊòØÂê¶‰øùÂ≠òÂõæÁâá
            
        Returns:
            output_path: ËæìÂá∫Êñá‰ª∂Ë∑ØÂæÑ
        """
        print("üé® Creating UMAP visualization...")
        
        # UMAPÈôçÁª¥
        reducer = umap.UMAP(
            n_components=2,
            n_neighbors=15,
            min_dist=0.1,
            metric='euclidean',
            random_state=42,
            verbose=False
        )
        
        embedding = reducer.fit_transform(cell_topic_matrix)
        
        # ÂàõÂª∫ÂõæË°®
        fig, axes = plt.subplots(1, 2, figsize=(16, 6))
        
        # Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõÁªÜËÉû‰ø°ÊÅØÔºåÂàõÂª∫Âü∫‰∫é‰∏ªÈ¢òÁöÑ‰ø°ÊÅØ
        if cell_info is None:
            n_cells = cell_topic_matrix.shape[0]
            main_topics = np.argmax(cell_topic_matrix, axis=1)
            
            cell_info = pd.DataFrame({
                'cell_type': [f'Topic_{t%8}' for t in main_topics],  # ÁÆÄÂåñ‰∏∫8ÁßçÁ±ªÂûã
                'batch': ['0'] * n_cells
            })
        
        # Â∑¶ÂõæÔºöÊåâÁªÜËÉûÁ±ªÂûãÁùÄËâ≤
        ax1 = axes[0]
        unique_types = cell_info['cell_type'].unique()
        
        for cell_type in unique_types:
            mask = cell_info['cell_type'] == cell_type
            ax1.scatter(embedding[mask, 0], embedding[mask, 1],
                       label=cell_type, alpha=0.6, s=10)
        
        ax1.set_xlabel('UMAP1')
        ax1.set_ylabel('UMAP2')
        ax1.set_title(f'UMAP - Cell Types ({dataset_name}-{n_topics})')
        ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=8)
        ax1.grid(True, alpha=0.3)
        
        # Âè≥ÂõæÔºöÊåâÊâπÊ¨°ÁùÄËâ≤
        ax2 = axes[1]
        unique_batches = cell_info['batch'].unique()
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728']
        
        for i, batch in enumerate(sorted(unique_batches)):
            mask = cell_info['batch'] == batch
            color = colors[i % len(colors)]
            ax2.scatter(embedding[mask, 0], embedding[mask, 1],
                       label=f'Batch {batch}', alpha=0.6, s=10, color=color)
        
        ax2.set_xlabel('UMAP1')
        ax2.set_ylabel('UMAP2')
        ax2.set_title(f'UMAP - Batches ({dataset_name}-{n_topics})')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        # ‰øùÂ≠òÂõæÁâá
        if save:
            output_path = self.output_dir / f"{dataset_name}_umap_{n_topics}.png"
            plt.savefig(output_path, dpi=300, bbox_inches='tight')
            print(f"‚úÖ UMAP saved: {output_path}")
        else:
            output_path = None
        
        plt.show()
        return str(output_path) if output_path else ""
    
    def create_topic_analysis(self,
                             cell_topic_matrix: np.ndarray,
                             topic_gene_matrix: Optional[np.ndarray] = None,
                             dataset_name: str = "Dataset",
                             n_topics: int = 20,
                             save: bool = True) -> str:
        """
        ÂàõÂª∫‰∏ªÈ¢òÂàÜÊûêÂõæË°®
        
        Args:
            cell_topic_matrix: Cell-topicÁü©Èòµ
            topic_gene_matrix: Topic-geneÁü©Èòµ
            dataset_name: Êï∞ÊçÆÈõÜÂêçÁß∞
            n_topics: ‰∏ªÈ¢òÊï∞Èáè
            save: ÊòØÂê¶‰øùÂ≠ò
            
        Returns:
            output_path: ËæìÂá∫Ë∑ØÂæÑ
        """
        print("üìä Creating topic analysis...")
        
        # ËÆ°ÁÆótopicÁªüËÆ°
        topic_sums = cell_topic_matrix.sum(axis=0)
        topic_percentages = (topic_sums / topic_sums.sum()) * 100
        
        # Shannon entropy
        probs = topic_percentages / 100
        shannon_entropy = -np.sum(probs * np.log(probs + 1e-10))
        effective_topics = np.exp(shannon_entropy)
        
        # ÂàõÂª∫ÂõæË°®
        if topic_gene_matrix is not None:
            fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        else:
            fig, axes = plt.subplots(1, 2, figsize=(15, 6))
            axes = [axes]
        
        # TopicÂàÜÂ∏ÉÊü±Áä∂Âõæ
        ax1 = axes[0] if len(axes) > 1 else axes[0][0]
        bars = ax1.bar(range(n_topics), topic_percentages, alpha=0.7, 
                      color=plt.cm.Set3(np.linspace(0, 1, n_topics)))
        ax1.set_title(f'Topic Distribution ({dataset_name}-{n_topics})', 
                     fontsize=14, fontweight='bold')
        ax1.set_xlabel('Topic ID')
        ax1.set_ylabel('Percentage (%)')
        ax1.grid(True, alpha=0.3)
        
        # Ê∑ªÂä†Êï∞ÂÄºÊ†áÁ≠æ
        for i, (bar, pct) in enumerate(zip(bars, topic_percentages)):
            if pct > 2:  # Âè™Ê†áÊ≥®Â§ß‰∫é2%ÁöÑ
                ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                        f'{pct:.1f}%', ha='center', va='bottom', fontsize=8)
        
        # Ë¥®ÈáèÊåáÊ†áÊñáÊú¨
        ax2 = axes[1] if len(axes) > 1 else axes[0][1]
        ax2.axis('off')
        
        metrics_text = f"""Topic Quality Metrics

Shannon Entropy: {shannon_entropy:.3f}
Effective Topics: {effective_topics:.1f} / {n_topics}
Max Topic %: {np.max(topic_percentages):.1f}%
Min Topic %: {np.min(topic_percentages):.1f}%

Quality Assessment:
{'‚úÖ High Diversity' if shannon_entropy > 2.5 else '‚ö†Ô∏è Low Diversity'}
{'‚úÖ Balanced Distribution' if np.max(topic_percentages) < 20 else '‚ö†Ô∏è Imbalanced'}
{'‚úÖ All Topics Active' if np.min(topic_percentages) > 1 else '‚ö†Ô∏è Inactive Topics'}

Dataset: {dataset_name}
Topics: {n_topics}
Cells: {cell_topic_matrix.shape[0]:,}
"""
        
        ax2.text(0.05, 0.95, metrics_text, transform=ax2.transAxes,
                fontfamily='monospace', fontsize=11, verticalalignment='top',
                bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue", alpha=0.8))
        
        # Â¶ÇÊûúÊúâtopic-geneÁü©ÈòµÔºåÊ∑ªÂä†Êõ¥Â§öÂàÜÊûê
        if topic_gene_matrix is not None and len(axes) > 1:
            # Cell-topicÁÉ≠ÂäõÂõæÔºàÈááÊ†∑Ôºâ
            ax3 = axes[1][0]
            sample_size = min(1000, cell_topic_matrix.shape[0])
            sample_indices = np.random.choice(cell_topic_matrix.shape[0], 
                                            sample_size, replace=False)
            sample_matrix = cell_topic_matrix[sample_indices]
            
            im = ax3.imshow(sample_matrix.T, aspect='auto', cmap='Blues', 
                           vmin=0, vmax=1)
            ax3.set_title(f'Cell-Topic Weights ({sample_size} cells)', 
                         fontsize=12, fontweight='bold')
            ax3.set_xlabel('Cells (sampled)')
            ax3.set_ylabel('Topics')
            plt.colorbar(im, ax=ax3, shrink=0.8)
            
            # TopicÁõ∏‰ººÊÄß
            ax4 = axes[1][1]
            from sklearn.metrics.pairwise import cosine_similarity
            topic_similarity = cosine_similarity(topic_gene_matrix)
            
            im2 = ax4.imshow(topic_similarity, cmap='RdBu_r', vmin=-1, vmax=1)
            ax4.set_title('Topic Similarity (Gene-based)', fontsize=12, fontweight='bold')
            ax4.set_xlabel('Topics')
            ax4.set_ylabel('Topics')
            plt.colorbar(im2, ax=ax4, shrink=0.8)
        
        plt.tight_layout()
        
        # ‰øùÂ≠òÂõæÁâá
        if save:
            output_path = self.output_dir / f"{dataset_name}_topic_analysis_{n_topics}.png"
            plt.savefig(output_path, dpi=300, bbox_inches='tight')
            print(f"‚úÖ Topic analysis saved: {output_path}")
        else:
            output_path = None
        
        plt.show()
        return str(output_path) if output_path else ""
    
    def create_comparison_plot(self,
                              results_dict: Dict[str, Dict],
                              dataset_name: str = "Dataset",
                              save: bool = True) -> str:
        """
        ÂàõÂª∫Â§ö‰∏™ÈÖçÁΩÆÁöÑÂØπÊØîÂõæ
        
        Args:
            results_dict: {config_name: {metrics...}} Ê†ºÂºèÁöÑÁªìÊûú
            dataset_name: Êï∞ÊçÆÈõÜÂêçÁß∞
            save: ÊòØÂê¶‰øùÂ≠ò
            
        Returns:
            output_path: ËæìÂá∫Ë∑ØÂæÑ
        """
        print("‚öñÔ∏è Creating comparison plot...")
        
        config_names = list(results_dict.keys())
        
        # ÊèêÂèñÊåáÊ†á
        shannon_entropies = [results_dict[name]['shannon_entropy'] for name in config_names]
        effective_topics = [results_dict[name]['effective_topics'] for name in config_names]
        max_topic_pcts = [np.max(results_dict[name]['topic_percentages']) for name in config_names]
        
        # ÂàõÂª∫ÂØπÊØîÂõæ
        fig, axes = plt.subplots(1, 3, figsize=(18, 6))
        
        # Shannon EntropyÂØπÊØî
        axes[0].bar(config_names, shannon_entropies, alpha=0.7, color='skyblue')
        axes[0].set_title('Shannon Entropy Comparison', fontweight='bold')
        axes[0].set_ylabel('Shannon Entropy')
        axes[0].grid(True, alpha=0.3)
        axes[0].tick_params(axis='x', rotation=45)
        
        # Effective TopicsÂØπÊØî
        axes[1].bar(config_names, effective_topics, alpha=0.7, color='lightgreen')
        axes[1].set_title('Effective Topics Comparison', fontweight='bold')
        axes[1].set_ylabel('Effective Topics')
        axes[1].grid(True, alpha=0.3)
        axes[1].tick_params(axis='x', rotation=45)
        
        # Max Topic %ÂØπÊØî
        axes[2].bar(config_names, max_topic_pcts, alpha=0.7, color='salmon')
        axes[2].set_title('Max Topic % Comparison', fontweight='bold')
        axes[2].set_ylabel('Max Topic %')
        axes[2].grid(True, alpha=0.3)
        axes[2].tick_params(axis='x', rotation=45)
        
        plt.tight_layout()
        
        if save:
            output_path = self.output_dir / f"{dataset_name}_comparison.png"
            plt.savefig(output_path, dpi=300, bbox_inches='tight')
            print(f"‚úÖ Comparison saved: {output_path}")
        else:
            output_path = None
        
        plt.show()
        return str(output_path) if output_path else ""
    
    def visualize_from_files(self,
                           dataset_name: str,
                           n_topics: int,
                           cell_info: Optional[pd.DataFrame] = None,
                           results_dir: str = "results") -> List[str]:
        """
        ‰ªé‰øùÂ≠òÁöÑÊñá‰ª∂ÂàõÂª∫ÊâÄÊúâÂèØËßÜÂåñ
        
        Args:
            dataset_name: Êï∞ÊçÆÈõÜÂêçÁß∞
            n_topics: ‰∏ªÈ¢òÊï∞Èáè
            cell_info: ÁªÜËÉû‰ø°ÊÅØ
            results_dir: ÁªìÊûúÁõÆÂΩï
            
        Returns:
            output_files: ÁîüÊàêÁöÑÊñá‰ª∂ÂàóË°®
        """
        print(f"üé® Creating visualizations for {dataset_name} ({n_topics} topics)")
        
        # Âä†ËΩΩÁü©Èòµ
        matrices = self.load_matrices(dataset_name, n_topics, results_dir)
        
        if 'cell_topic' not in matrices:
            print("‚ùå Cell-topic matrix not found!")
            return []
        
        output_files = []
        
        # UMAPÂèØËßÜÂåñ
        umap_file = self.create_umap_plot(
            matrices['cell_topic'],
            cell_info,
            dataset_name,
            n_topics
        )
        if umap_file:
            output_files.append(umap_file)
        
        # ‰∏ªÈ¢òÂàÜÊûê
        topic_gene_matrix = matrices.get('topic_gene', None)
        analysis_file = self.create_topic_analysis(
            matrices['cell_topic'],
            topic_gene_matrix,
            dataset_name,
            n_topics
        )
        if analysis_file:
            output_files.append(analysis_file)
        
        print(f"‚úÖ Generated {len(output_files)} visualization files")
        return output_files

def main():
    """ÊµãËØïÂáΩÊï∞"""
    # Á§∫‰æãÔºö‰∏∫20-topicÁªìÊûúÂàõÂª∫ÂèØËßÜÂåñ
    visualizer = ScFastopicVisualizer("visualization")
    
    # ‰ªéÊñá‰ª∂ÂàõÂª∫ÂèØËßÜÂåñ
    output_files = visualizer.visualize_from_files(
        dataset_name="PBMC",
        n_topics=20,
        results_dir="results"
    )
    
    print(f"Generated files: {output_files}")

if __name__ == "__main__":
    main()